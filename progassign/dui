#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Std;
use Data::Dumper; 
#use POSIX;

#flushes the buffer after ever print
$|=1;
my $totalFiles= 0;
my %opts;
my @lookThrough = ();
use constant KILO => 1024;
use constant MEGA => 1048576;
use constant GIGA => 1073741824;

#Sorting and printing a hash
sub sortHash(@){
    my %hash = @_;
    my %sortedHash = %hash;
    my $count = 0;

#   solved the -N issue
    my $amount = thePrintAmount(%sortedHash);
#   replace the reference with the size
    %sortedHash = replaceWithSize(%sortedHash);
 
#   Sort
    foreach (sort {($sortedHash{$b} <=> $sortedHash{$a})} keys %sortedHash){
	if($count <= $amount){   
	    next if($_ eq '.');
	    printf "%-4s %-30s %-12s %-20s\n", "$count)", substr($_,0,29), returnSize($sortedHash{$_}), histogram($_,%sortedHash);
	    push (@lookThrough, $hash{$_});
	}
    } continue {
	$count = $count+1;
    }
print "@lookThrough\n";
}

#okayyyyyyy so files need to display stat info, so we need to put strings into an array 
#using grep, taken from stat, to make this shit good
sub statinfo($){
    my $arr= shift @_;
    if(ref $arr eq "ARRAY"){
	print "
Device:\t $arr->[0]
inode:\t $arr->[1]
mode:\t $arr->[2]
nlink:\t $arr->[3]
uid:\t $arr->[4]
gid:\t $arr->[5]
rdev:\t $arr->[6]
size:\t $arr->[7]
atime:\t $arr->[8]
mtime:\t $arr->[9]
ctime:\t $arr->[10]
blksz:\t $arr->[11]
blocks:\t $arr->[12]
"
    }
}

#Creates Hash in Hashes of the directory given                       
sub recursiveOpenDir1{
    my %thehash;
    my $sum = 0;
    my ($directory)=$_[0];
    opendir my $dh, $directory or die "Issues with opening Directory: $!";
    foreach my $file (readdir($dh)){
	printTotalFiles();
	if(-d "$directory/$file" && "$file" ne '.' && "$file" ne '..'){
	    $thehash{$file} = recursiveOpenDir1("$directory/$file");
	    $sum = $sum + $thehash{$file}->{'.'};
	}elsif(-f "$directory/$file" || -l "$directory/$file"){
	    my @arr = stat "$directory/$file";
	    $thehash{$file} = \@arr;
	    $sum = FileDo($sum, "$directory/$file");
	}
    }
    $thehash{'.'} = $sum;
    return \%thehash;
}

# to make global variables for the -v -N
#and then use the opts hash everytime so you can use one fucntion
#

#%opts holds the options
#this will have to change bc opts scope is to small
sub options(){
    getopts ("gmkhvN:", \%opts);
#    print %opts, "\n";
#   print "@ARGV\n";  
    
#    sortHash(($opts{N}),%{recursiveOpenDir1($ARGV[0])}) if defined $opts{N};
    
}

#Called without a directory name
#usage message then exit
sub helpOptions(){
    if($#ARGV < 0 || defined $opts{h}){
    print "
Usage: dui [options] directory
Options:
-N num\t Display only the top 'num' entries for each directory.
-g\t Display sizes in 1073741824-byte (1-Gbyte) blocks.
-m\t Display sizes in 1048576-byte (1-Mbyte) blocks.
-k\t Display sizes in 1024-byte (1-Kbyte) blocks.
-h\t Display sizes as \"human-readable\" numbers, where
\t all sizes include a suffix to indicate units of
\t bytes or {kilo,mega,giga}bytes.

-v\t Enable verbose/debugging output.
";
    if ($#ARGV < 0){
	exit(0);
    }
    }
}

sub thePrintAmount(@){
    my %subHash = @_;
    my $amount=0;
    if (defined $opts{N}){
	$amount = $opts{N};
    } else {
	$amount= keys %subHash;
    }
    return $amount;
}

# Fill the new hash with the appropriate size (not hash references)
sub replaceWithSize(@){
   my %replaceHash = @_;
   foreach my $val (keys %replaceHash){
#http://perldoc.perl.org/functions/ref.html
	if(ref $replaceHash{$val} eq "HASH"){
	    $replaceHash{$val} = $replaceHash{$val}->{'.'};
	}elsif (ref $replaceHash{$val} eq "ARRAY"){
	    $replaceHash{$val} = $replaceHash{$val}->[7];
	}
    }
   return %replaceHash;
}

#Returns size user requested
#http://perldoc.perl.org/functions/int.html
sub returnSize($){
    my $sizeInBytes = shift @_;
    if ($sizeInBytes > 0){
	if (defined $opts{k}){
	    $sizeInBytes= int($sizeInBytes/KILO);
	} elsif (defined $opts{m}){
	    $sizeInBytes= int($sizeInBytes/MEGA);
	} elsif (defined $opts{g}){
	    $sizeInBytes= int($sizeInBytes/GIGA);
	}
    }
    return humanReadable($sizeInBytes);
}

sub humanReadable($){
    my $size = shift @_;
    if ($size > 0){
	if (defined $opts{k} && defined $opts{h}){
	    $size = "$size" . "K";
	} elsif (defined $opts{m} && defined $opts{h}){
	    $size = "$size" . "M";
	} elsif (defined $opts{g} && defined $opts{h}){
	    $size = "$size" . "G";
	}elsif (defined $opts{h}){
	    $size = "$size" . "B";
	}
    }
    return $size;
}

#returns the number of # that the file contributes
sub histogram($@){
    my ($val, %histoHash) = @_;
#   get percent of file has then * 20 spots to fill and + 0.5 to round up
    my $histogram = (($histoHash{$val}/$histoHash{'.'})*20)+0.5;
    return "#"x"$histogram";
}

sub printTotalFiles{
    if($totalFiles % 100 == 0){
	print "\r$totalFiles";
    }
}

sub FileDo($$){
    my ($sum, $file) = @_;
    if(defined -s $file){
	$sum = $sum + (-s $file);
	$totalFiles= $totalFiles +1;
    }
    if(defined $opts{v}){
	print "$file\n";
    }		    
    return $sum;
}

sub explore{
    print "Explore (h for Help)? ";
}

#toggle with options defined
sub stdinOptions($){
    print "$_";
    helpOptions if($_ =~ m/^h$/);
    print "HOllA DIEGO\n" if(m/^\d/);

#need to grab single chars for each match to put into array
    my @matches = ($_ =~ m/-([gmkhN])+/g);
	print "matches: " . "@matches\n";

    foreach my $option (@matches){
	toggle($option);
    }

#if(m/-N (\d)/);
#if(m/-g/

#   clear array with references
    @lookThrough = ();
}

sub toggle($$){
    my $char = shift @_;
    my $listLength = shift @_;
    if(defined $opts{$char}){
	delete $opts{$char};
    }else{
	$opts{$char} = '1';
    }
    if ($char eq 'N'){
	$opts{$char} = $listLength;
    }
    print Dumper %opts;
}

sub main(){
    do{
	helpOptions;
	if(defined $_){
	    stdinOptions($_);
	}else{
	    options;
	}
	sortHash(%{recursiveOpenDir1($ARGV[0])});
	explore();
    }while(<STDIN>)
}


main;
#options;
#helpOptions;
#openDir($ARGV[0]);
#EditOpenDirArrayRef($ARGV[0]);
#my $hash = recursiveOpenDir1($ARGV[0]);
#print Dumper (%{$hash});
#sortHash(10,%{$hash});

exit(0);
