#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Std;
use Data::Dumper; 
#use POSIX;

#flushes the buffer after ever print
$|=1;
my $totalFiles= 0;
my %opts;
use constant KILO => 1024;
use constant MEGA => 1048576;
use constant GIGA => 1073741824;

#Sorting and printing a hash
sub sortHash(@){
    my %hash = @_;
    my %sortedHash = %hash;
    my $count = 1;
    my @lookthrough = ();
#   solved the -N issue
    my $amount = thePrintAmount(%sortedHash);
#   replace the hash reference with the size in the hash values
    %sortedHash = replaceWithSize(%sortedHash);
 
     print " Done\n";

#   Sort
    foreach (sort {($sortedHash{$b} <=> $sortedHash{$a})} keys %sortedHash){
	if($count <= $amount){   
	    printf "%-4s %-30s %-12s %-20s\n", "$count)", substr($_,0,29), returnSize($sortedHash{$_}), histogram($_,%sortedHash);
	    push (@lookthrough, $hash{$_});
	}
    $count = $count+1;
    }
#    print "$sortedHash{'.'}\n";
#    print "@lookthrough\n";
}

#Creates Hash in Hashes of the directory given                       
sub recursiveOpenDir1{
    my %thehash;
    my $sum = 0;
    my ($directory)=$_[0];
    opendir my $dh, $directory or die "Issues with opening Directory: $!";
    foreach my $file (readdir($dh)){
	printTotalFiles();
	if(-d "$directory/$file" && "$file" ne '.' && "$file" ne '..'){
	    $thehash{$file} = recursiveOpenDir1("$directory/$file");
	    $sum = $sum + $thehash{$file}->{'.'};
	}elsif(-f "$directory/$file" || -l "$directory/$file"){
	    $thehash{$file} = -s "$directory/$file";
	    $sum = FileDo($sum, "$directory/$file");
	}
    }
    $thehash{'.'} = $sum;
    return \%thehash;
}

# to make global variables for the -v -N
#and then use the opts hash everytime so you can use one fucntion
#

#%opts holds the options
#this will have to change bc opts scope is to small
sub options(){
    getopts ("gmkhvN:", \%opts);
#    print %opts, "\n";
#   print "@ARGV\n";  
    
#    sortHash(($opts{N}),%{recursiveOpenDir1($ARGV[0])}) if defined $opts{N};
    
}

#Called without a directory name
#usage message then exit
sub helpOptions(){
    if($#ARGV < 0 || defined $opts{h}){
    print "
Usage: dui [options] directory
Options:
-N num\t Display only the top 'num' entries for each directory.
-g\t Display sizes in 1073741824-byte (1-Gbyte) blocks.
-m\t Display sizes in 1048576-byte (1-Mbyte) blocks.
-k\t Display sizes in 1024-byte (1-Kbyte) blocks.
-h\t Display sizes as \"human-readable\" numbers, where
\t all sizes include a suffix to indicate units of
\t bytes or {kilo,mega,giga}bytes.

-v\t Enable verbose/debugging output.
";
    if ($#ARGV < 0){
	exit(0);
    }
    }
}

sub thePrintAmount(@){
    my %subHash = @_;
    my $amount=0;
    if (defined $opts{N}){
	$amount = $opts{N};
    } else {
	$amount= keys %subHash;
    }
    return $amount;
}

# Fill the new hash with the appropriate size (not hash references)
sub replaceWithSize(@){
   my %replaceHash = @_;
   foreach my $val (keys %replaceHash){
	if(ref $replaceHash{$val} eq "HASH"){
	    $replaceHash{$val} = $replaceHash{$val}->{'.'};
	}
    }
   return %replaceHash;
}

#Returns size user requested
#http://perldoc.perl.org/functions/int.html
sub returnSize($){
    my $sizeInBytes = shift @_;
    if ($sizeInBytes > 0){
	if (defined $opts{k}){
	    $sizeInBytes= $sizeInBytes/KILO;
	} elsif (defined $opts{m}){
	    $sizeInBytes= $sizeInBytes/MEGA;
	} elsif (defined $opts{g}){
	    $sizeInBytes= $sizeInBytes/GIGA;
	}
    }
#   Return the rounded down version of the number
#   If rounded up is required add 0.5
    return int($sizeInBytes);
}

#returns the number of # that the file contributes
sub histogram($@){
    my ($val, %histoHash) = @_;
#   get percent of file has then * 20 spots to fill and + 0.5 to round up
    my $histogram = (($histoHash{$val}/$histoHash{'.'})*20)+0.5;
    return "#"x"$histogram";
}

sub printTotalFiles{
    if($totalFiles % 100 == 0){
	print "\r$totalFiles";
    }
}

sub FileDo($$){
    my ($sum, $file) = @_;
    if(defined -s $file){
	$sum = $sum + (-s $file);
	$totalFiles= $totalFiles +1;
    }
    if(defined $opts{v}){
	print "$file\n";
    }		    
    return $sum;
}

sub explore{
    print "Explore (h for Help)? ";
}

#toggle with options defined
sub stdinOptions($){
    print "$_";
}

sub main(){
    do{
	helpOptions;
	if(defined $_){
	    stdinOptions($_);
	}else{
	    options;
	}
	sortHash(%{recursiveOpenDir1($ARGV[0])});
	explore();
    }while(<STDIN>)
}


main;
#options;
#helpOptions;
#openDir($ARGV[0]);
#EditOpenDirArrayRef($ARGV[0]);
#my $hash = recursiveOpenDir1($ARGV[0]);
#print Dumper (%{$hash});
#sortHash(10,%{$hash});

exit(0);
