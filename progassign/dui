#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Std;
use Data::Dumper; 
#use POSIX;

#flushes the buffer after ever print
$|=1;
my $totalFiles= 0;
my %opts;
my @currentDirRef = ();
my @PathDirRef = ();
my $PARENTDIRREF;
use constant KILO => 1024;
use constant MEGA => 1048576;
use constant GIGA => 1073741824;

#Sorting and printing a hash
sub PrintDir(@){
    my %hash = @_;
    my %sortedHash = %hash;
    my $count = 1;
#   solved the -N issue
    my $amount = TopNumEntries(%sortedHash);
#   replace the reference with the size
    %sortedHash = replaceWithSize(%sortedHash);
#   print according to file/dir size
    foreach (sort {($sortedHash{$b} <=> $sortedHash{$a})} keys %sortedHash){
	if($count <= $amount){   
	    next if($_ eq '.');
	    printf "%-4s %-30s %-12s %-20s\n", "$count)", substr($_,0,29), 
	    RequestedFileSize($sortedHash{$_}), histogram($_,%sortedHash);
	    push (@currentDirRef, $hash{$_});
	} 
	$count = $count+1;
    }
}

#okayyyyyyy so files need to display stat info, so we need to put strings into an array 
#using grep, taken from stat, to make this shit good
sub StatInfo($){
    my $arr= shift @_;
    if(ref $arr eq "ARRAY"){
	print "Device:\t $arr->[0]
inode:\t $arr->[1]
mode:\t $arr->[2]
nlink:\t $arr->[3]
uid:\t $arr->[4]
gid:\t $arr->[5]
rdev:\t $arr->[6]
size:\t $arr->[7]
atime:\t $arr->[8]
mtime:\t $arr->[9]
ctime:\t $arr->[10]
blksz:\t $arr->[11]
blocks:\t $arr->[12]
"
    }
}

#Creates Hash in Hashes of the directory given                       
sub OpenDir{
    my %thehash;
    my $sum = 0;
    my ($directory)=$_[0];
    opendir my $dh, $directory or die "Issues with opening Directory: $!";
    foreach my $file (readdir($dh)){
	printTotalFiles();
	if(-d "$directory/$file" && "$file" ne '.' && "$file" ne '..'){
	    $thehash{$file} = OpenDir("$directory/$file");
	    $sum = $sum + $thehash{$file}->{'.'};
	}elsif(-f "$directory/$file" || -l "$directory/$file"){
	    my @arr = stat "$directory/$file";
	    $thehash{$file} = \@arr;
	    $sum = DirSum($sum, "$directory/$file");
	    Verbose($file);
	}
    }
    $thehash{'.'} = $sum;
    return \%thehash;
}

#%opts holds the options
sub options(){
    getopts ("gmkhvN:", \%opts);
}

#Called without a directory name
#usage message then exit
sub Help(){
    if($#ARGV < 0 || defined $opts{H}){
    print "
Usage: dui [options] directory
Options:
-N num\t Display only the top 'num' entries for each directory.
-b\t Display previous directory
-r\t Return to current directory (file viewing)
-g\t Display sizes in 1073741824-byte (1-Gbyte) blocks.
-m\t Display sizes in 1048576-byte (1-Mbyte) blocks.
-k\t Display sizes in 1024-byte (1-Kbyte) blocks.
-h\t Display sizes as \"human-readable\" numbers, where
\t all sizes include a suffix to indicate units of
\t bytes or {kilo,mega,giga}bytes.
-q\t Quit

-v\t Enable verbose/debugging output.
";
    if ($#ARGV < 0){
	exit(0);
    }else{
#	Delete so H wont have toggle effect
	delete $opts{'H'};
    }
    }
}

sub TopNumEntries(@){
    my %subHash = @_;
    my $amount=0;
    if (defined $opts{N}){
	$amount = $opts{N};
    } else {
	$amount= keys %subHash;
    }
    return $amount;
}

#Fill the new hash with the appropriate size (not hash references)
sub replaceWithSize(@){
   my %replaceHash = @_;
   foreach my $val (keys %replaceHash){
#       http://perldoc.perl.org/functions/ref.html
	if(ref $replaceHash{$val} eq "HASH"){
	    $replaceHash{$val} = $replaceHash{$val}->{'.'};
	}elsif (ref $replaceHash{$val} eq "ARRAY"){
	    $replaceHash{$val} = $replaceHash{$val}->[7];
	}
    }
   return %replaceHash;
}


#Returns size user requested
#http://perldoc.perl.org/functions/int.html
sub RequestedFileSize($){
    my $sizeInBytes = shift @_;
    if ($sizeInBytes > 0){
	if (defined $opts{k}){
	    $sizeInBytes= int($sizeInBytes/KILO);
	} elsif (defined $opts{m}){
	    $sizeInBytes= int($sizeInBytes/MEGA);
	} elsif (defined $opts{g}){
	    $sizeInBytes= int($sizeInBytes/GIGA);
	}
    }
    return humanReadable($sizeInBytes);
}

sub humanReadable($){
    my $size = shift @_;
    if ($size > 0){
	if (defined $opts{k} && defined $opts{h}){
	    $size = "$size" . "K";
	} elsif (defined $opts{m} && defined $opts{h}){
	    $size = "$size" . "M";
	} elsif (defined $opts{g} && defined $opts{h}){
	    $size = "$size" . "G";
	}elsif (defined $opts{h}){
	    $size = "$size" . "B";
	}
    }
    return $size;
}

sub Verbose($){
    if(defined $opts{v}){
	print "@_\n";
    }		    
}

#returns the number of # that the file contributes
sub histogram($@){
    my ($val, %histoHash) = @_;
#   get percent of file has then * 20 spots to fill and + 0.5 to round up
    my $histogram = (($histoHash{$val}/$histoHash{'.'})*20)+0.5;
    return "#"x"$histogram";
}

sub printTotalFiles{
    print "Scanning\n" if($totalFiles == 0);
    if($totalFiles % 100 == 0 && $totalFiles != 0){
	print "\r$totalFiles";
    }
}

sub DirSum($$){
    my ($sum, $file) = @_;
    if(defined -s $file){
	$sum = $sum + (-s $file);
	$totalFiles= $totalFiles +1;
    }
    return $sum;
}


sub Explore{
    if (ref $PathDirRef[$#PathDirRef] eq "HASH"){
	 print "Explore (H for Help)? ";
	}elsif (ref $PathDirRef[$#PathDirRef] eq "ARRAY"){
	    print "Return (r for return): ";
	}
}

sub ExploreDirFile(){
    if(defined $opts{'Explore'}){
	my $requestIndex = ($opts{'Explore'})-1;
	if(ref $currentDirRef[$requestIndex] eq "HASH" ||
	    ref $currentDirRef[$requestIndex] eq "ARRAY"){
	    push(@PathDirRef, $currentDirRef[$requestIndex]);  
	}
    }
    delete $opts{'Explore'};
    @currentDirRef = ();
}

#toggle with options defined
sub StdinOptions($){
    $opts{'Explore'}=$1 if(m/^(\d+)/);
    $opts{'b'}='1' if(m/b/);
    $opts{'N'}=$1 if(m/N (\d+)/);
    $opts{'H'}='1' if(m/H/);
    $opts{'r'}='1' if(m/r/);
    $opts{'q'}='1' if(m/q/);
#   gmkh - toggle
    foreach my $var (my @myarray = (m/-?([gmkh])/g)){
	ToggleOptions($var);
    }
#   print Dumper %opts;
    SpecialOptions();
}

#will call functions that deal
#with Bq and directory requests
sub SpecialOptions(){
#   Directory request
    ExploreDirFile();
#   Back a Directory
    StepBackDir();
#   Quit
    Quit();
}

sub Quit(){
    if(defined $opts{'q'}){
	exit(0);
    }
}

sub StepBackDir(){
    if(defined $opts{'b'} || defined $opts{'r'}){
	pop @PathDirRef;
    }
    delete $opts{'b'};
    delete $opts{'r'}
}


#gmkh
sub ToggleOptions($){
    my $char = shift @_;
    if(defined $opts{$char}){
	delete $opts{$char};
    }else{
	$opts{$char} = '1';
    }
#    print Dumper %opts;
}


sub Main(){
    do{
	options;
	if(defined $_){
	    StdinOptions($_);
	}
	Help;
	if($#PathDirRef == -1){
	    $PARENTDIRREF = OpenDir($ARGV[0]);
	    push (@PathDirRef, $PARENTDIRREF);
	}	    
	if (ref $PathDirRef[$#PathDirRef] eq "HASH"){
	    PrintDir(%{$PathDirRef[$#PathDirRef]});
	}elsif (ref $PathDirRef[$#PathDirRef] eq "ARRAY"){
	    StatInfo($PathDirRef[$#PathDirRef]);
	}
	Explore();
    }while(<STDIN>)
}


Main;

exit(0);
